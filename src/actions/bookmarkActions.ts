
'use server';

import type { Bookmark } from '@/types';
import { connectToDatabase } from '@/lib/mongodb';
import type { Collection, ObjectId } from 'mongodb';
import { unstable_noStore as noStore } from 'next/cache';

const BOOKMARKS_COLLECTION = 'bookmarks';

interface BookmarkDocument extends Omit<Bookmark, 'id'> {
  _id?: ObjectId;
}

// Helper to map MongoDB document to Bookmark type
function mapDocumentToBookmark(doc: BookmarkDocument & { _id: ObjectId }): Bookmark {
  return {
    ...doc,
    id: doc._id.toString(), // Convert ObjectId to string for client-side use
    description: doc.description || '',
    isPrivate: doc.isPrivate || false,
  };
}

async function getBookmarksCollection(): Promise<Collection<BookmarkDocument>> {
  const { db } = await connectToDatabase();
  return db.collection<BookmarkDocument>(BOOKMARKS_COLLECTION);
}


export async function getBookmarksAction(): Promise<Bookmark[]> {
  noStore();
  console.log('Server Action: getBookmarksAction called');
  try {
    const bookmarksCollection = await getBookmarksCollection();
    const bookmarkDocs = await bookmarksCollection.find({}).toArray();
    return bookmarkDocs.map(doc => mapDocumentToBookmark(doc as BookmarkDocument & { _id: ObjectId }));
  } catch (error) {
    console.error("Error fetching bookmarks from DB:", error);
    return []; // Return empty array on error to prevent UI breakage
  }
}

export async function addBookmarkAction(bookmarkData: Omit<Bookmark, 'id'>): Promise<Bookmark> {
  noStore();
  console.log('Server Action: addBookmarkAction called with:', bookmarkData);
  try {
    const bookmarksCollection = await getBookmarksCollection();
    const newBookmarkDoc: BookmarkDocument = {
      ...bookmarkData,
      description: bookmarkData.description || '',
      isPrivate: bookmarkData.isPrivate || false,
    };
    // _id will be generated by MongoDB

    const result = await bookmarksCollection.insertOne(newBookmarkDoc);
    if (!result.insertedId) {
        throw new Error('Failed to insert bookmark into DB.');
    }
    
    // Fetch the inserted document to get all fields including _id, then map it
    // This is more robust if there are default values or transformations in DB layer (though not here)
    const insertedDoc = await bookmarksCollection.findOne({ _id: result.insertedId });
    if (!insertedDoc) {
        throw new Error('Failed to retrieve inserted bookmark from DB.');
    }
    return mapDocumentToBookmark(insertedDoc as BookmarkDocument & { _id: ObjectId });

  } catch (error) {
    console.error("Error adding bookmark to DB:", error);
    throw error; // Re-throw to be caught by client
  }
}

export async function updateBookmarkAction(bookmarkToUpdate: Bookmark): Promise<Bookmark> {
  noStore();
  console.log('Server Action: updateBookmarkAction called with:', bookmarkToUpdate);
  try {
    const bookmarksCollection = await getBookmarksCollection();
    const { id, ...updateData } = bookmarkToUpdate;

    const result = await bookmarksCollection.findOneAndUpdate(
      { _id: new (require('mongodb').ObjectId)(id) },
      { $set: {
        name: updateData.name,
        url: updateData.url,
        categoryId: updateData.categoryId,
        description: updateData.description || '',
        isPrivate: updateData.isPrivate || false,
        // icon is not typically stored directly for bookmarks, but if it were:
        // icon: updateData.icon 
      } },
      { returnDocument: 'after' } // Returns the updated document
    );

    if (!result) {
      throw new Error('Bookmark not found for update or update failed.');
    }
    return mapDocumentToBookmark(result as BookmarkDocument & { _id: ObjectId });
  } catch (error) {
    console.error("Error updating bookmark in DB:", error);
    throw error;
  }
}

export async function deleteBookmarkAction(bookmarkId: string): Promise<{ id: string }> {
  noStore();
  console.log('Server Action: deleteBookmarkAction called for ID:', bookmarkId);
  try {
    const bookmarksCollection = await getBookmarksCollection();
    const result = await bookmarksCollection.deleteOne({ _id: new (require('mongodb').ObjectId)(bookmarkId) });

    if (result.deletedCount === 0) {
      // This might happen if ID is invalid or bookmark already deleted
      console.warn(`Bookmark with ID ${bookmarkId} not found for deletion, or already deleted.`);
    }
    return { id: bookmarkId };
  } catch (error) {
    console.error("Error deleting bookmark from DB:", error);
    throw error;
  }
}

export async function deleteBookmarksByCategoryIdAction(categoryId: string): Promise<{ deletedCount: number }> {
  noStore();
  console.log('Server Action: deleteBookmarksByCategoryIdAction called for category ID:', categoryId);
  try {
    const bookmarksCollection = await getBookmarksCollection();
    const result = await bookmarksCollection.deleteMany({ categoryId: categoryId });
    console.log(`Deleted ${result.deletedCount} bookmarks for category ID ${categoryId}`);
    return { deletedCount: result.deletedCount };
  } catch (error) {
    console.error(`Error deleting bookmarks for category ID ${categoryId} from DB:`, error);
    throw error;
  }
}
