
'use server';

import type { Category } from '@/types';
import { connectToDatabase } from '@/lib/mongodb';
import type { Collection, ObjectId } from 'mongodb';
import { unstable_noStore as noStore } from 'next/cache';

const CATEGORIES_COLLECTION = 'categories';

interface CategoryDocument extends Omit<Category, 'id'> {
  _id?: ObjectId;
}

// Helper to map MongoDB document to Category type
function mapDocumentToCategory(doc: CategoryDocument & { _id: ObjectId }): Category {
  return {
    ...doc,
    id: doc._id.toString(),
  };
}

async function getCategoriesCollection(): Promise<Collection<CategoryDocument>> {
  const { db } = await connectToDatabase();
  return db.collection<CategoryDocument>(CATEGORIES_COLLECTION);
}

// Ensure default category exists
async function ensureDefaultCategory(categoriesCollection: Collection<CategoryDocument>) {
  const defaultCategoryExists = await categoriesCollection.findOne({ name: '通用书签' }); // Assuming 'id' field is string _id
  if (!defaultCategoryExists) {
    await categoriesCollection.insertOne({
      // _id will be generated by MongoDB
      name: '通用书签',
      isVisible: true,
      icon: 'Folder',
      isPrivate: false,
    });
    console.log("Created default '通用书签' category in DB.");
  }
}


export async function getCategoriesAction(): Promise<Category[]> {
  noStore();
  console.log('Server Action: getCategoriesAction called');
  try {
    const categoriesCollection = await getCategoriesCollection();
    await ensureDefaultCategory(categoriesCollection); // Ensure default category exists
    
    const categoryDocs = await categoriesCollection.find({}).toArray();
    return categoryDocs.map(doc => mapDocumentToCategory(doc as CategoryDocument & { _id: ObjectId }));
  } catch (error) {
    console.error("Error fetching categories from DB:", error);
    // Attempt to return a minimal default if DB fails, to prevent UI breakage
    // This is a fallback, real error handling might be more sophisticated
    return [{ id: 'default-fallback', name: '通用书签 (错误)', isVisible: true, icon: 'Folder', isPrivate: false }];
  }
}

export async function addCategoryAction(name: string, icon?: string, isPrivate?: boolean): Promise<Category> {
  noStore();
  console.log('Server Action: addCategoryAction called with:', { name, icon, isPrivate });
  try {
    const categoriesCollection = await getCategoriesCollection();
    
    const existingCategory = await categoriesCollection.findOne({ name: { $regex: `^${name}$`, $options: 'i' } });
    if (existingCategory) {
      throw new Error('Category name already exists');
    }

    const newCategoryDoc: CategoryDocument = {
      name,
      icon: icon || 'Folder',
      isVisible: true,
      isPrivate: isPrivate || false,
    };
    const result = await categoriesCollection.insertOne(newCategoryDoc);
    
    if (!result.insertedId) {
        throw new Error('Failed to insert category into DB.');
    }
    
    return mapDocumentToCategory({ ...newCategoryDoc, _id: result.insertedId });
  } catch (error) {
    console.error("Error adding category to DB:", error);
    throw error; // Re-throw to be caught by client
  }
}

export async function updateCategoryAction(categoryToUpdate: Category): Promise<Category> {
  noStore();
  console.log('Server Action: updateCategoryAction called with:', categoryToUpdate);
  try {
    const categoriesCollection = await getCategoriesCollection();
    const { id, ...updateData } = categoryToUpdate;

    // Check for name collision if name is being changed
    if (updateData.name) {
        const existingCategoryWithSameName = await categoriesCollection.findOne({
            name: { $regex: `^${updateData.name}$`, $options: 'i' },
            _id: { $ne: new (require('mongodb').ObjectId)(id) } // Exclude the current category itself
        });
        if (existingCategoryWithSameName) {
            throw new Error('Another category with this name already exists');
        }
    }
    
    // Prevent changing name or privacy of 'default' category (identified by its actual name for robustness)
    const currentCategory = await categoriesCollection.findOne({ _id: new (require('mongodb').ObjectId)(id) });
    if (currentCategory && currentCategory.name === '通用书签' && currentCategory.icon === 'Folder') { // More robust check for default
        if (updateData.name && updateData.name !== '通用书签') {
            console.warn("Attempt to change name of '通用书签' category blocked.");
            updateData.name = '通用书签'; // Revert name change
        }
        if (updateData.isPrivate === true) {
            console.warn("Attempt to make '通用书签' category private blocked.");
            updateData.isPrivate = false; // Revert privacy change
        }
    }


    const result = await categoriesCollection.findOneAndUpdate(
      { _id: new (require('mongodb').ObjectId)(id) },
      { $set: {
          name: updateData.name,
          icon: updateData.icon || 'Folder',
          isVisible: updateData.isVisible,
          isPrivate: updateData.isPrivate || false,
      } },
      { returnDocument: 'after' }
    );

    if (!result) {
      throw new Error('Category not found for update or update failed.');
    }
    return mapDocumentToCategory(result as CategoryDocument & { _id: ObjectId });
  } catch (error) {
    console.error("Error updating category in DB:", error);
    throw error;
  }
}

export async function deleteCategoryAction(categoryId: string): Promise<{ id: string }> {
  noStore();
  console.log('Server Action: deleteCategoryAction called for ID:', categoryId);
  try {
    const categoriesCollection = await getCategoriesCollection();
    
    const categoryToDelete = await categoriesCollection.findOne({ _id: new (require('mongodb').ObjectId)(categoryId) });
    if (categoryToDelete && categoryToDelete.name === '通用书签' && categoryToDelete.icon === 'Folder') {
      throw new Error("The '通用书签' (default) category cannot be deleted.");
    }

    // Note: Deleting associated bookmarks should be handled.
    // Current app calls deleteBookmarkAction in a loop from client-side.
    // For a DB implementation, a more direct DB operation would be better (e.g., update bookmarks to a default category or delete them).
    // For now, this action only deletes the category itself.

    const result = await categoriesCollection.deleteOne({ _id: new (require('mongodb').ObjectId)(categoryId) });
    if (result.deletedCount === 0) {
      // This might happen if ID is invalid or category already deleted
      console.warn(`Category with ID ${categoryId} not found for deletion, or already deleted.`);
    }
    
    // Ensure 'default' category always exists (if accidentally removed or during init)
    // This is re-checked by getCategoriesAction too, but good as a post-delete check.
    // await ensureDefaultCategory(categoriesCollection); 
    // This is handled by getCategoriesAction so no need to explicitly call here unless specific post-delete logic needed for default.

    return { id: categoryId };
  } catch (error) {
    console.error("Error deleting category from DB:", error);
    throw error;
  }
}
